# 実装計画: サーバアプリ再起動機能（未保存確認・サービス前提）

目的
- WebUI から安全にサーバアプリ（HokuyoHub）を再起動できる機能を提供する。
- 未保存の変更がある場合は確認ダイアログを表示し、ユーザ承認後に再起動を実行する。
- 運用ではサービスとして起動している前提（systemd/launchd 等）を想定し、再起動の実行方法を抽象化する。

対象
- REST API 新設:
  - POST /api/v1/server/restart
  - 実装: [src/io/rest_handlers.cpp](src/io/rest_handlers.cpp)
- WebUI:
  - ヘッダー/メニューに「Restart Server」ボタンを追加
  - 未保存変更の検知・確認ダイアログ・進捗/結果表示
  - 実装: [webui/index.html](webui/index.html), [webui/app.js](webui/app.js)

現状の把握
- WebUI は設定変更/ROI/センサー等を WebSocket/REST で更新している。
  - フィルタ: [handleFilterUpdate()](src/io/ws_handlers.cpp:425)
  - DBSCAN: [handleDbscanUpdate()](src/io/ws_handlers.cpp:498)
  - ROI(ワールドマスク): [handleWorldUpdate()](src/io/ws_handlers.cpp:313)
  - センサー: [handleSensorUpdate()](src/io/ws_handlers.cpp:289), REST CRUD([src/io/rest_handlers.cpp](src/io/rest_handlers.cpp))
- サーバ側は Config の Load/Import/Save を REST で提供済み（設定の保存手段がある）。
  - 例: /api/v1/configs/save, /api/v1/configs/load（[src/io/rest_handlers.cpp](src/io/rest_handlers.cpp:1337) など）

変更方針
- 再起動 API は「外部コマンドの実行」により行う。OS/デプロイごとにコマンドを差し替え可能な抽象化層を設ける。
  - 例:
    - systemd: systemctl restart hokuyohub
    - launchd(macOS): launchctl kickstart -k system/io.hokuyohub または brew services restart hokuyohub
    - 開発時: 自分自身に SIGHUP/SIGTERM の後、プロセス監視側で再起動
- セキュリティ:
  - 認可トークン必須（既存 authorize を流用: [authorize()](src/io/rest_handlers.cpp:9)）
  - レート制限/CSRF は運用で考慮（本計画ではスコープ外）

具体手順

1) REST: /api/v1/server/restart を追加
- 仕様:
  - POST /api/v1/server/restart
  - Header: Authorization: Bearer <token>（必要時）
  - Body: 空 or { "mode":"graceful" } 等の将来拡張
  - 200 OK: { "restarting": true, "message": "restart issued" }
  - 4xx/5xx: エラーメッセージ
- 実装案:
  - [src/io/rest_handlers.cpp](src/io/rest_handlers.cpp) にメソッド追加（ハンドラ登録はルータ設定側に準拠）
  - OS/環境に応じた実行コマンドは関数化:
    - 例: bool RestApi::restartService()
      - macOS (開発想定): launchctl または brew services を優先。なければシェルスクリプトを呼ぶ
      - Linux: systemctl をデフォルトに
  - 実行は非同期 or 同期:
    - 同期でコマンド発行→直ちに 200 を返す（接続は直後に切れる可能性があり、フロントは再接続リトライ）

2) WebUI: UI 要素/未保存フラグ/確認
- UI 追加:
  - ヘッダー領域（[webui/index.html](webui/index.html:11)）付近に「Restart Server」ボタンを追加
  - クリックで以下フロー:
    1) 未保存フラグをチェック
    2) 未保存ありの場合 confirm ダイアログ（「未保存の変更があります。再起動を実行しますか？」）
    3) 承認後、fetch('/api/v1/server/restart', { method:'POST' }) を実行
    4) 成否トースト表示（[showNotification()](webui/app.js:2619)）
    5) 3〜5 秒後に WebSocket の再接続を試み、snapshot を再要求（[refreshBrowserStateFromServer()](webui/app.js:2372)）
- 未保存フラグの管理:
  - 変更イベントをフックして dirty=true:
    - フィルタ更新送信時: [sendFilterConfig()](webui/app.js:1557)
    - DBSCAN更新送信時: [sendDbscanConfig()](webui/app.js:2833)
    - ROI更新送信時: [sendWorldMaskUpdate()](webui/app.js:2213)
    - センサー更新送信時: sensor.update（複数箇所: [webui/app.js:2035, 2138] など）
  - サーバからの snapshot/load/import の完了時に dirty=false へ（ベースライン更新）
    - m.type==='sensor.snapshot' 受信時（[webui/app.js:1089]）に dirty=false
    - configs/load/import 成功時（[webui/app.js:2517, 2601]）にも dirty=false
  - 任意: dirty の視覚表示（ヘッダーに • マーク等）

3) 例外/フォールバック
- 再起動コマンドが使えない環境では 501 Not Implemented を返す設計も可。
- 開発ローカルでは仮実装として 200 OK を返すのみ→UI は「再接続待ちタイムアウト」で検知。

エラーハンドリング/UX
- 401: トークン未設定/無効→通知
- 5xx: コマンド失敗→通知、ログ参照を促す
- タイムアウト: WS が一定時間内に再接続できなければリトライ案内

受け入れ基準（テスト）
- dirty=false の状態で Restart → API 200、WS 切断→再接続、snapshot 取得で元通り
- dirty=true の状態で確認ダイアログが表示され、キャンセル時は再起動しない
- 開発/本番（macOS/ Linux）で適切なコマンドが実行される（環境設定で切替可能）

ロールバック手順
- UI から Restart ボタンを削除
- REST から /api/v1/server/restart を削除/無効化

非機能/セキュリティ
- 認可必須。実運用では HTTPS 経由推奨
- コマンドインジェクション対策（固定コマンド＋引数固定）

関連リンク
- フィルタ更新: [handleFilterUpdate()](src/io/ws_handlers.cpp:425), [sendFilterConfig()](webui/app.js:1557)
- DBSCAN更新: [handleDbscanUpdate()](src/io/ws_handlers.cpp:498), [sendDbscanConfig()](webui/app.js:2833)
- ROI更新: [handleWorldUpdate()](src/io/ws_handlers.cpp:313), [sendWorldMaskUpdate()](webui/app.js:2213)
- スナップショット配布: [sendSnapshotTo()](src/io/ws_handlers.cpp:257), [buildSnapshot()](src/io/ws_handlers.cpp:173)