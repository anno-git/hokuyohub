# 03 DBSCAN2D 実装方針

概要
- 点群クラスタリングを 2D DBSCAN で実装し、30 FPS 前後の処理に耐える性能を目標とします。入力はフラット配列 xy とセンサーID配列 sid、出力は Cluster 配列。インターフェイスは既存のスタブに準拠します。

関連箇所
- 実装スタブ: [DBSCAN2D::run()](src/detect/dbscan.cpp:4)
- 宣言/データ型: [dbscan.h](src/detect/dbscan.h:9), [DBSCAN2D::run()](src/detect/dbscan.h:14), [Cluster 構造体](src/detect/dbscan.h:7)
- 呼び出し側（将来置換）: [main の集約コールバック](src/main.cpp:68)

前提データモデル
- 入力:
  - xy: [x0, y0, x1, y1, ...] の float フラット配列（要素数は常に偶数）
  - sid: 各点に対応するセンサーID uint8（0..255）
  - t_ns, seq: メタ情報（処理やID採番に使用可）
- 出力 Cluster:
  - id（フレーム内一意の連番で可）
  - bbox: minx, miny, maxx, maxy
  - centroid: cx, cy（算術平均）
  - count: 点数
  - sensor_mask: sid を bit 和で集計（最大256だが、0..7 の想定を超える場合は上位ビットへの対応をドキュメント化）

アルゴリズム方針
- 近傍探索の加速:
  - 均一グリッド（セルサイズ ≈ eps）で空間分割する。
  - 各点をセルにバケットし、近傍探索時は自身のセル＋周辺 8 セルのみを走査。
- DBSCAN の流れ:
  1. 全点を未訪問とし、点 i ごとに近傍半径 eps 以内の点集合 N(i) を探索。
  2. |N(i)| ≥ minPts ならばコア点として新クラスターを開始し、N(i) を拡張して密度連結な点をすべて訪問済みにし同一クラスタに割り当て。
  3. |N(i)| < minPts の点は一旦未分類（またはノイズ）。後続の拡張で取り込まれる可能性あり。
- 距離計算:
  - 2D ユークリッド距離。平方根を避けるため距離二乗と eps^2 比較を基本とする。

性能/メモリ方針
- 時間計算量: 近傍探索をバケットで局所化し、平均 O(N) 近辺を目標（密度集中ケースは悪化しうる）。
- メモリ:
  - インデックス配列、訪問フラグ、クラスタID配列を事前確保し再利用。
  - グリッドのハッシュマップは負荷に応じてリザーブ（例: 入力点数に比例）。
- アロケーションの抑制:
  - std::vector は clear() + capacity 再利用。map ではなく std::unordered_map を基本とし、キーは 64bit の組（セル座標）をハッシュ化。

スレッド/リアルタイム性
- run() はシングルスレッド前提で一回の呼び出し内で完結。並列化は不要（将来検討）。
- 複数フレーム間での状態は持たない（追跡はスコープ外）。

クラスタ属性の集計
- bbox: min/max を拡張中に逐次更新。
- centroid: 単純平均（Σx/Σ1, Σy/Σ1）。外れ値へのロバスト性は今回は不要。
- sensor_mask: 各 sid のビットを OR 集計（sid ∈ [0,255] を想定）。

ID 採番
- フレーム内で 0..K-1 を付与。トラッキングや安定IDはスコープ外。

パラメータ
- eps, minPts はコンストラクタおよび setter で更新可能: [DBSCAN2D::setParams](src/detect/dbscan.h:13)
- 実装では実効 eps^2 を事前計算し、距離二乗比較に用いる。

エッジケース
- N < minPts のとき: 全点はノイズ（クラスタ0件）
- 重複点（同一座標）: minPts 評価に寄与。セル分割は問題なし。
- 無限/NaN: 入力前提として無いものとし、発見時はスキップまたはログ。

ログ/可観測性
- 実行時間の軽量計測（デバッグ時のみ）を設けると性能回帰検出に有用。
- 例外は基本投げない設計（内部で防御し、エラー時は空配列返却）。

テスト/評価
- 正当性:
  - 既知配置（2クラスタ＋ノイズ）の検証と bbox/centroid/count の一致。
  - minPts, eps の境界値テスト。
- 性能:
  - 代表的な点数（例: 3k, 10k）で平均/最大処理時間を記録し目標内を確認。
- sid マスク:
  - 単一/複数センサー混在でビット和が期待通りになること。

将来拡張
- 高密度領域向けの kd-tree 版の検討（効果がある場合に切替）。
- ノイズ点の統計、クラスタ信頼度などの派生指標。
- 並列実装（SIMD/タスク分割）の検証。

実装着手順（推奨手順）
1. グリッド構築ロジックを実装（セルキー生成、バケット投入）。
2. 近傍探索関数を分離し、単体で検証可能にする。
3. DBSCAN 本体（訪問フラグ、拡張処理、クラスタ属性集計）。
4. 小規模ケースの正当性テスト→性能測定→メモリ/予約のチューニング。
5. main 統合（タスク 02）前に最小の統合テストを実施。

参照
- スタブ実装: [DBSCAN2D::run()](src/detect/dbscan.cpp:4)
- インターフェイス: [DBSCAN2D](src/detect/dbscan.h:9), [DBSCAN2D::run()](src/detect/dbscan.h:14)
- 呼び出し箇所（置換予定）: [main 集約コールバック](src/main.cpp:68)