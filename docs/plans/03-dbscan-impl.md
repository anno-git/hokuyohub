# 03 DBSCAN2D 実装方針

概要
- 点群クラスタリングを 2D DBSCAN で実装し、30 FPS 前後の処理に耐える性能を目標とします。入力はフラット配列 xy とセンサーID配列 sid、出力は Cluster 配列。インターフェイスは既存のスタブに準拠します。

関連箇所
- 実装スタブ: [DBSCAN2D::run()](src/detect/dbscan.cpp:4)
- 宣言/データ型: [dbscan.h](src/detect/dbscan.h:9), [DBSCAN2D::run()](src/detect/dbscan.h:14), [Cluster 構造体](src/detect/dbscan.h:7)
- 呼び出し側（将来置換）: [main の集約コールバック](src/main.cpp:68)

前提データモデル
- 入力:
  - xy: [x0, y0, x1, y1, ...] の float フラット配列（要素数は常に偶数）
  - sid: 各点に対応するセンサーID uint8（0..255）
  - t_ns, seq: メタ情報（処理やID採番に使用可）
- 出力 Cluster:
  - id（フレーム内一意の連番で可）
  - bbox: minx, miny, maxx, maxy
  - centroid: cx, cy（算術平均）
  - count: 点数
  - sensor_mask: sid を bit 和で集計（最大256だが、0..7 の想定を超える場合は上位ビットへの対応をドキュメント化）

アルゴリズム方針
- 近傍探索の加速（距離正規化対応）:
  - 均一グリッドで空間分割するが、基準セル長は h ≈ s_min（近距離側の最小スケール）とする。
  - 各点 i をセルにバケットし、近傍探索時は点ごとの探索半径 eps_i に応じて自身のセル＋周辺セルを走査。セル半径は ceil(eps_i / h)。
- DBSCAN の流れ（可変半径版）:
  1. 全点を未訪問とし、点 i ごとに正規化距離 d_norm(i,j) ≤ eps_norm を満たす点集合 N(i) を探索。
  2. |N(i)| ≥ minPts ならばコア点として新クラスターを開始し、N(i) を拡張して密度連結な点をすべて同一クラスタに割り当て。
  3. |N(i)| < minPts の点は一旦未分類（またはノイズ）。後続の拡張で取り込まれる可能性あり。
- 距離計算（正規化）:
  - d_norm^2(i,j) = ||p_i − p_j||^2 / (s_i^2 + s_j^2)。比較は d_norm^2 ≤ eps_norm^2。
  - 局所スケール s_i^2 = σ_r(r_i)^2 + (k · r_i · Δθ(sid_i))^2。ここで r_i = sqrt(x_i^2 + y_i^2)。
  - σ_r(r) は σ0 + α·r の一次式、Δθ はセンサーごと（sid）に定義する。
  - 補足: 実探索では eps_i = eps_norm · s_i を用いてグリッドの探索セル半径を決め、候補収集後に d_norm 比較でフィルタする。

性能/メモリ方針
- 時間計算量: 近傍探索をバケットで局所化し、平均 O(N) 近辺を目標（密度集中ケースは悪化しうる）。
- メモリ:
  - インデックス配列、訪問フラグ、クラスタID配列を事前確保し再利用。
  - グリッドのハッシュマップは負荷に応じてリザーブ（例: 入力点数に比例）。
- アロケーションの抑制:
  - std::vector は clear() + capacity 再利用。map ではなく std::unordered_map を基本とし、キーは 64bit の組（セル座標）をハッシュ化。
- 負荷制御（可変半径の上限）:
  - 探索セル半径 R_max を設定し、ceil(eps_i / h) ≤ R_max に制限する（例: R_max=3〜5）。
  - 候補点数の上限 M_max を設定し、超過時は早期打切りまたはランダムサブサンプリングを選択。
  - h は s_min に合わせるが、実装では近距離過密対策として h を微調整可能にしておく。

スレッド/リアルタイム性
- run() はシングルスレッド前提で一回の呼び出し内で完結。並列化は不要（将来検討）。
- 複数フレーム間での状態は持たない（追跡はスコープ外）。

クラスタ属性の集計
- bbox: min/max を拡張中に逐次更新。
- centroid: 単純平均（Σx/Σ1, Σy/Σ1）。外れ値へのロバスト性は今回は不要。
- sensor_mask: 各 sid のビットを OR 集計（sid ∈ [0,255] を想定）。

複数センサー統合と誤差モデル
- 観測点 i の距離 r_i とセンサー固有パラメータに基づく局所スケール s_i を導入し、センサー間の点密度差・精度差を吸収する。
- 正規化距離
  - d_norm(i,j)^2 = ||p_i − p_j||^2 / (s_i^2 + s_j^2)
  - 判定は d_norm^2 ≤ eps_norm^2 を用いるため平方根は不要。
- 実務指針
  - 座標系は外部較正済みを前提。残留外乱がある場合は σ0 をやや大きめに設定しロバスト化。
  - 高負荷/多重観測では小ボクセルで事前ダウンサンプリングし重複点を抑制（代表点には最小 s_i を選ぶなど）。

ID 採番
- フレーム内で 0..K-1 を付与。トラッキングや安定IDはスコープ外。

パラメータ
- 正規化版の主要パラメータ: eps_norm（次元なし閾値）, minPts, k（角度項係数）。
- センサー別モデル（sid→Δθ, σ0, α）を保持し、σ_r(r)=σ0+α·r と Δθ(sid) を s_i の算出に用いる。
- 比較は d_norm^2 ≤ eps_norm^2。探索セル半径は eps_i = eps_norm · s_i から決定する。
- 既存API互換: 既存の [DBSCAN2D::setParams](src/detect/dbscan.h:13) は暫定的に eps を eps_norm と見なす（将来は専用設定APIを追加）。
- 初期値（暫定）: Δθ=0.25°、σ_r(r)=0.02+0.004·r [m]、レンジ=0.2..10 m、eps_norm=2.5、minPts=5、k=1.5。

エッジケース
- N < minPts のとき: 全点はノイズ（クラスタ0件）
- 重複点（同一座標）: minPts 評価に寄与。セル分割は問題なし。
- 無限/NaN: 入力前提として無いものとし、発見時はスキップまたはログ。

ログ/可観測性
- 実行時間の軽量計測（デバッグ時のみ）を設けると性能回帰検出に有用。
- 例外は基本投げない設計（内部で防御し、エラー時は空配列返却）。

テスト/評価
- 正当性:
  - 既知配置（2クラスタ＋ノイズ）の検証と bbox/centroid/count の一致。
  - minPts, eps の境界値テスト。
- 性能:
  - 代表的な点数（例: 3k, 10k）で平均/最大処理時間を記録し目標内を確認。
- sid マスク:
  - 単一/複数センサー混在でビット和が期待通りになること。

将来拡張
- 高密度領域向けの kd-tree 版の検討（効果がある場合に切替）。
- ノイズ点の統計、クラスタ信頼度などの派生指標。
- 並列実装（SIMD/タスク分割）の検証。

実装着手順（推奨手順）
1. グリッド構築ロジックを実装（セルキー生成、バケット投入）。
2. 近傍探索関数を分離し、単体で検証可能にする。
3. DBSCAN 本体（訪問フラグ、拡張処理、クラスタ属性集計）。
4. 小規模ケースの正当性テスト→性能測定→メモリ/予約のチューニング。
5. main 統合（タスク 02）前に最小の統合テストを実施。

参照
- スタブ実装: [DBSCAN2D::run()](src/detect/dbscan.cpp:4)
- インターフェイス: [DBSCAN2D](src/detect/dbscan.h:9), [DBSCAN2D::run()](src/detect/dbscan.h:14)
- 呼び出し箇所（置換予定）: [main 集約コールバック](src/main.cpp:68)
## 仕様更新詳細: 正規化距離と可変半径の近傍探索

本節は、距離依存の点密度変化と複数センサー統合に対応するための実装上の詳細仕様を定義する（既存のアルゴリズム方針に対する補遺）。

### 1) 局所スケール s_i と正規化距離 d_norm

- 極座標からの誤差伝播を簡易モデル化し、各点 i に局所スケール s_i を与える。
  - s_i^2 = σ_r(r_i)^2 + (k · r_i · Δθ_sid)^2
  - r_i = sqrt(x_i^2 + y_i^2)、Δθ_sid はセンサー sid ごとの角度分解能（ラジアン）
  - σ_r(r) = σ0 + α · r（各 sid ごとに σ0, α を持つ一次モデル）
- 正規化距離:
  - d_norm^2(i,j) = ||p_i − p_j||^2 / (s_i^2 + s_j^2)
  - 近傍判定は d_norm^2 ≤ eps_norm^2
- 暫定既定値（運用で調整）:
  - Δθ = 0.25°（約 0.0043633 rad）、σ_r(r) = 0.02 + 0.004 · r [m]
  - eps_norm = 2.5、minPts = 5、k = 1.5
- 実装メモ:
  - r_i は hypotf(x_i, y_i) で算出し、s_i と eps_i = eps_norm · s_i を前計算して配列に保持
  - 近傍候補の収集は eps_i を用いた空間探索、最終判定は d_norm 比較

### 2) グリッド設計と可変探索半径

- 基準セル長 h（自動調整）:
  - 各フレームで s_i を一度だけ全点計算し、s_median を求める
  - h = clamp(0.8 · s_median, h_min, h_max)
  - 推奨: h_min = 0.01 m、h_max = 0.20 m
  - 軽量フォールバック: N &lt; 2k の場合は h を固定 0.03 m としてもよい
- セル座標:
  - ix = floor(x / h)、iy = floor(y / h)
  - セルキーは 64bit にパックして std::unordered_map でバケット（キー衝突はバケット内の線形走査）
- 探索半径（セル単位）:
  - 各点 i で R_i = min(R_max, ceil(eps_i / h))
  - 推奨初期: R_max = 5
  - 走査は [ix − R_i .. ix + R_i] × [iy − R_i .. iy + R_i] の周辺セル
  - 最大探索セル数（ハード上限）: (2 · R_max + 1)^2。R_max=5 なら 121。実装では minPts 到達時の早期終了と併用して負荷を抑制
  - 参考: 初期モデルからの具体値（計算例）
    - Δθ = 0.25°（約 0.0043633 rad）、k = 1.5、r_min = 0.2 m、r_max = 10 m、σ_r(r) = 0.02 + 0.004 · r [m]、eps_norm = 2.5
    - s_min ≈ sqrt(0.0208^2 + (1.5 · 0.2 · 0.0043633)^2) ≈ 0.02084 m
    - h の参考値 h_ref = eps_norm · s_min ≈ 2.5 · 0.02084 ≈ 0.0521 m（近距離基準のセル長の目安）
    - s_max ≈ sqrt(0.06^2 + (1.5 · 10 · 0.0043633)^2) ≈ 0.08884 m
    - R_i ≈ ceil(s_i / s_min) の範囲は概ね 1..5。従って R_max は 5 を初期値とするのが妥当
    - 備考: 実装では h = clamp(0.8 · s_median, h_min, h_max) を優先しつつ、上記 h_ref をチューニングの参考にする
- 候補数の上限と早期打ち切り:
  - 候補点数 M_i が M_max を超過したら早期打ち切り（以降はサブサンプルまたは直ちに非コアとして扱う運用を選択）
  - 推奨初期: M_max = min(600, 0.05 · N)
  - 候補数が minPts に満たない場合は、密度拡張に入らず非コアとしてスキップ（後の拡張で取り込まれる可能性は維持）
  - 近傍数カウントが minPts に到達した時点でセル走査を早期終了可（コア点判定の負荷削減）
- 性能目標:
  - 平均 O(N) 近傍探索を維持。高密度ケースでは R_i と M_max により悪化を緩和
  - 事前に buckets.reserve( ~ N )、インデックス配列や訪問フラグは再利用

### 3) マルチセンサー統合と重み付け

- sid ごとに Δθ、σ0、α を保持し s_i へ反映することで、センサー間の精度差を距離判定に織り込む
- キャリブレーション誤差が懸念される場合は σ0 をやや大きめに設定してロバスト化
- 重複点の抑制（任意）:
  - 小さめボクセルで事前ダウンサンプル（各ボクセルで最小 s_i の点を代表にする等）
  - これは探索負荷の低減にも有効
- 設定の外部化:
  - sid → {Δθ, σ0, α} のテーブルを設定ファイルに保持（例: [configs/sensors.yaml](configs/sensors.yaml)）
  - 未設定の sid は既定値を使用

### 4) 既存 API との整合

- 既存の [DBSCAN2D::setParams](src/detect/dbscan.h:13) の第一引数 eps は当面 eps_norm として扱う（将来、専用の正規化設定 API を追加予定）
- 実装は [DBSCAN2D::run](src/detect/dbscan.cpp:4) 内に s_i 算出、可変半径探索、d_norm 判定、minPts ロジックを追加
- 出力フォーマット（[Cluster 構造体](src/detect/dbscan.h:7)）は変更なし

### 5) ベンチマークとチューニング手順

- 点数 N ≈ 3k / 10k の代表ケースで処理時間を計測（平均/最大）
- パラメータ調整の推奨順:
  1. h（セル長）の上限/下限
  2. R_max（セル探索半径上限）と M_max（候補上限）
  3. eps_norm と minPts（分割/結合バランス）
  4. センサー別 σ0, α, Δθ（遠距離の結合率と近距離の過分割を同時に最適化）

## 実装タスクと評価計画

### 実装対象 ✅ 完了
- ✅ 実装: [DBSCAN2D::run()](src/detect/dbscan.cpp:31) に s_i 算出、可変半径探索、正規化距離判定、minPts ロジックを追加
- ✅ 既存API互換: 既存の [DBSCAN2D::setParams](src/detect/dbscan.h:23) の第一引数 eps は当面 eps_norm として扱う
- ✅ 新API追加: [DBSCAN2D::setAngularCoeff()](src/detect/dbscan.h:24) と性能制御の setter を [dbscan.h](src/detect/dbscan.h:25) に追加
- ✅ 設定拡張: [configs/default.yaml](configs/default.yaml:18) の dbscan セクションに eps_norm/minPts/k と h_min/h_max/R_max/M_max を追加
- ✅ 設定パース: [load_app_config()](src/config/config.cpp:69) で新パラメータを解析し [AppConfig](src/config/config.h:57) に格納
- ✅ パラメータ配線: [main.cpp](src/main.cpp:40) で新設定を DBSCAN インスタンスに適用

### 実装済み最適化 ✅
- ✅ minPts セマンティクス: 包含的（自身を含む近傍数）に変更し [dbscan.h](src/detect/dbscan.h:27) でドキュメント化
- ✅ 動的候補上限: M_dyn = min(M_max_, floor(0.05·N)) をフレームごとに適用 [dbscan.cpp](src/detect/dbscan.cpp:38)
- ✅ 小規模フレーム対応: N < 2000 で h = 0.03m の固定値フォールバック [dbscan.cpp](src/detect/dbscan.cpp:56)
- ✅ グリッド容量最適化: reserve(max(N/3, 16)) でより適切な初期容量 [dbscan.cpp](src/detect/dbscan.cpp:65)
- ✅ sensor_mask ガード: sid >= 8 の場合は無視して 8bit マスクを保護 [dbscan.cpp](src/detect/dbscan.cpp:180)
- ✅ デフォルト値調整: R_max_ = 5 に変更して計画と整合 [dbscan.h](src/detect/dbscan.h:17)
- ✅ プロファイリング: DBSCAN_PROFILE フラグで軽量タイミング計測を追加 [dbscan.cpp](src/detect/dbscan.cpp:29)

### 評価項目（目標）
- 処理時間: N≈10k で ≤ 33ms（30 FPS 相当）
- 正当性: 代表配置で bbox/centroid/count の妥当性、遠近混在シーンで過分割/過結合の低減
- 統合: 複数センサー混在で sensor_mask 集計と正規化距離の適用確認
- メモリ: バッファ再利用による安定動作（再アロケーション最小化）

### 推奨初期パラメータ（実装前の目安）
```yaml
# 基本パラメータ
eps_norm: 2.5        # 正規化距離閾値
minPts: 5            # コア点最小近傍数
k: 1.5               # 角度項係数

# センサーモデル（既定値の例）
delta_theta_deg: 0.25  # 角度分解能
sigma0: 0.02           # 距離ノイズ定数項 [m]
alpha: 0.004           # 距離ノイズ線形係数 [m/m]

# 性能制御（初期目安）
h_min: 0.01
h_max: 0.20
R_max: 5
max_cells_scan: 121   # (2*R_max+1)^2 の目安。実装ではフレーム/設定に応じて自動導出可
M_max: 600
```

### 懸念点への対応方針 ✅ 実装済み
- ✅ 距離依存密度低下: 局所スケール s_i による d_norm 判定で補正
- ✅ 複数センサー統合: sid ごとの Δθ, σ0, α を s_i に反映し等重み問題を回避
- ✅ 負荷制御: R_max と M_max による探索範囲/候補数の上限設定でスパイクを緩和

### 実装決定事項
- **minPts セマンティクス**: 包含的（近傍数に自身を含む）を採用。これは一般的な DBSCAN 実装と整合。
- **早期終了**: 現在は候補収集を完了してから判定。将来的に minPts 到達時の早期終了を検討可能。
- **設定互換性**: eps は eps_norm として扱い、eps_norm が明示的に設定されていない場合は eps を使用。
- **センサーモデル**: デフォルトモデル（sid=0）を全センサーに適用。個別設定は将来拡張として準備済み。

### 残存課題（将来対応）
- 個別センサーモデル設定の YAML 配線（API は準備済み）
- 高密度領域での kd-tree 切り替え検討
- 並列実装（SIMD/タスク分割）の検証
- 単体テストとマイクロベンチマークの追加