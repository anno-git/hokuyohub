name: Optimized Docker Matrix Build

permissions:
  contents: read
  actions: read
  security-events: write

on:
  push:
    branches: [ main, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  BUILDKIT_PROGRESS: plain

jobs:
  # Pre-build job for cache preparation and URG library
  prepare-cache:
    name: Prepare Build Cache
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      cache-key: ${{ steps.cache-keys.outputs.cache-key }}
      urg-cache-key: ${{ steps.cache-keys.outputs.urg-cache-key }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    - name: Generate cache keys
      id: cache-keys
      run: |
        DOCKER_CACHE_KEY="docker-buildkit-${{ runner.os }}-${{ hashFiles('docker/Dockerfile.rpi*', 'docker/build.sh', 'CMakeLists.txt', 'cmake/**') }}"
        URG_CACHE_KEY="urg-library-${{ runner.os }}-${{ hashFiles('external/urg_library/**') }}"
        echo "cache-key=${DOCKER_CACHE_KEY}" >> $GITHUB_OUTPUT
        echo "urg-cache-key=${URG_CACHE_KEY}" >> $GITHUB_OUTPUT
        echo "Docker cache key: ${DOCKER_CACHE_KEY}"
        echo "URG cache key: ${URG_CACHE_KEY}"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          network=host
        buildkitd-flags: |
          --allow-insecure-entitlement security.insecure
          --allow-insecure-entitlement network.host

  # Parallel build matrix for multiple platforms
  build-matrix:
    name: Build ${{ matrix.platform }}
    runs-on: ubuntu-latest
    needs: prepare-cache
    permissions:
      contents: read
      packages: write
      security-events: write
    strategy:
      fail-fast: false
      max-parallel: 2
      matrix:
        platform: [linux/amd64, linux/arm64]
        include:
        - platform: linux/amd64
          platform-pair: linux-amd64
          dockerfile: docker/Dockerfile.rpi.optimized
        - platform: linux/arm64
          platform-pair: linux-arm64
          dockerfile: docker/Dockerfile.rpi.optimized

    env:
      DOCKER_BUILDKIT: 1
      BUILDKIT_PROGRESS: plain
      DOCKER_BUILD_MEMORY_LIMIT: 6g

    steps:
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
      with:
        platforms: all

    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        submodules: recursive
        fetch-depth: 0

    - name: Compute image tag
      run: |
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          TAG=${GITHUB_REF#refs/tags/}
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          TAG="latest"
        else
          TAG='${{ github.ref_name }}'
        fi
        echo "TAG=$TAG" >> $GITHUB_ENV
        echo "Using TAG=$TAG"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          network=host
        buildkitd-flags: |
          --allow-insecure-entitlement security.insecure
          --allow-insecure-entitlement network.host

    - name: Log in to Container Registry
      if: github.event_name != 'pull_request'
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch,suffix=-${{ matrix.platform-pair }}
          type=ref,event=pr,suffix=-${{ matrix.platform-pair }}
          type=semver,pattern={{version}},suffix=-${{ matrix.platform-pair }}
          type=raw,value=latest,suffix=-${{ matrix.platform-pair }},enable={{is_default_branch}}

    - name: Cache URG Library Build
      uses: actions/cache@v4
      with:
        path: |
          external/urg_library/current/src/*.a
          external/urg_library/current/include
          build-cache/urg-${{ matrix.platform-pair }}
        key: ${{ needs.prepare-cache.outputs.urg-cache-key }}-${{ matrix.platform-pair }}-${{ matrix.platform }}
        restore-keys: |
          urg-library-${{ runner.os }}-${{ matrix.platform-pair }}-${{ matrix.platform }}
          urg-library-${{ runner.os }}-${{ matrix.platform-pair }}

    - name: Cache Docker BuildKit layers
      uses: actions/cache@v4
      with:
        path: /tmp/.buildx-cache-${{ matrix.platform-pair }}
        key: ${{ needs.prepare-cache.outputs.cache-key }}-${{ matrix.platform-pair }}
        restore-keys: |
          docker-buildkit-${{ runner.os }}-${{ matrix.platform-pair }}

    - name: Pre-build URG Library (if not cached)
      run: |
        echo "::group::Pre-build URG Library for ${{ matrix.platform }}"
        mkdir -p build-cache/urg-${{ matrix.platform-pair }}
        if [ ! -d "build-cache/urg-${{ matrix.platform-pair }}" ]; then
          echo "Error: Build context path does not exist"
          exit 1
        fi
        echo "Build context validated: $(pwd)/build-cache/urg-${{ matrix.platform-pair }}"
        if [ ! -f "external/urg_library/current/src/liburg_c.a" ]; then
          echo "Building URG library from source..."
          cd external/urg_library/current
          make clean
          make -j$(nproc)
          cp -r include ../../../build-cache/urg-${{ matrix.platform-pair }}/
          cp src/*.a ../../../build-cache/urg-${{ matrix.platform-pair }}/
        else
          echo "URG library already built, using cache"
        fi
        echo "::endgroup::"

    - name: Monitor system resources before build
      run: |
        echo "=== System Resource Status ==="
        df -h
        free -h
        echo "Used memory %: $(free -m | awk 'NR==2{printf \"%.1f%%\\n\", $3*100/$2 }')"

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ${{ matrix.dockerfile }}
        platforms: ${{ matrix.platform }}
        target: runtime
        push: ${{ github.event_name != 'pull_request' }}
        # â† metadata ã®ã‚¿ã‚°ã«åŠ ãˆã¦ã€Œå¿…ãšå­˜åœ¨ã™ã‚‹è‡ªå‰ã‚¿ã‚°ã€ã‚’ä»˜ä¸Ž
        tags: |
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}-${{ matrix.platform-pair }}
          ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: |
          type=local,src=/tmp/.buildx-cache-${{ matrix.platform-pair }}
          type=gha,scope=build-${{ matrix.platform-pair }}
        cache-to: |
          type=local,dest=/tmp/.buildx-cache-${{ matrix.platform-pair }},mode=max
          type=gha,scope=build-${{ matrix.platform-pair }},mode=max
        build-contexts: |
          urg-cache=build-cache/urg-${{ matrix.platform-pair }}
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          PLATFORM=${{ matrix.platform }}
          DOCKER_BUILD_MEMORY_LIMIT=${{ env.DOCKER_BUILD_MEMORY_LIMIT }}

    - name: Verify pushed image exists
      if: github.event_name != 'pull_request'
      run: |
        IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}-${{ matrix.platform-pair }}"
        echo "Verifying image: $IMAGE"
        docker buildx imagetools inspect "$IMAGE"

    - name: Monitor system resources after build
      run: |
        echo "=== Post-build System Resource Status ==="
        df -h
        free -h
        docker system df
        if [ $(df / | tail -1 | awk '{print $4}' | sed 's/[^0-9]//g') -lt 2048 ]; then
          echo "Low disk space detected, cleaning up..."
          docker system prune -f --volumes
        fi

    - name: Extract build artifacts
      if: github.event_name != 'pull_request'
      run: |
        echo "::group::Extract Build Artifacts for ${{ matrix.platform }}"
        IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}-${{ matrix.platform-pair }}"
        echo "Pulling image: $IMAGE"
        docker pull --platform=${{ matrix.platform }} "$IMAGE"
        ./scripts/utils/extract_docker_artifacts.sh "$IMAGE" "${{ matrix.platform-pair }}" || echo "Extraction failed, continuing..."
        echo "::endgroup::"

    - name: Upload platform-specific artifacts
      if: github.event_name != 'pull_request'
      uses: actions/upload-artifact@v4
      with:
        name: hokuyohub-${{ matrix.platform-pair }}   # linux-amd64 / linux-arm64
        path: |
          dist/
        retention-days: 30

  # Parallel testing job
  test-matrix:
    name: Test ${{ matrix.platform }}
    runs-on: ubuntu-latest
    needs: [prepare-cache, build-matrix]
    if: github.event_name != 'pull_request' && needs.build-matrix.result == 'success'
    permissions:
      contents: read
      packages: read
    strategy:
      fail-fast: false
      matrix:
        platform: [linux/amd64, linux/arm64]
        include:
        - platform: linux/amd64
          platform-pair: linux-amd64
        - platform: linux/arm64
          platform-pair: linux-arm64
    steps:
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
      with:
        platforms: all

    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Compute image tag
      run: |
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          TAG=${GITHUB_REF#refs/tags/}
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          TAG="latest"
        else
          TAG='${{ github.ref_name }}'
        fi
        echo "TAG=$TAG" >> $GITHUB_ENV
        echo "Using TAG=$TAG"

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Test container startup
      run: |
        echo "::group::Test Container Startup - ${{ matrix.platform }}"
        docker run -d --name test-container-${{ matrix.platform-pair }} --platform ${{ matrix.platform }} \
          -p 8080:8080 \
          ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}-${{ matrix.platform-pair }} || echo "Container start failed"
        sleep 10
        if docker ps | grep -q test-container-${{ matrix.platform-pair }}; then
          echo "âœ… Container started successfully"
          docker logs test-container-${{ matrix.platform-pair }}
        else
          echo "âŒ Container failed to start"
          docker logs test-container-${{ matrix.platform-pair }} || true
        fi
        docker stop test-container-${{ matrix.platform-pair }} || true
        docker rm test-container-${{ matrix.platform-pair }} || true
        echo "::endgroup::"

    - name: Run API tests
      if: matrix.platform == 'linux/amd64'
      run: |
        echo "::group::API Tests"
        chmod +x scripts/testing/test_rest_api.sh
        ./scripts/testing/test_rest_api.sh || echo "API tests failed, continuing..."
        echo "::endgroup::"

  # Security scanning in parallel
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    needs: build-matrix
    if: github.event_name != 'pull_request' && needs.build-matrix.result == 'success'
    permissions:
      contents: read
      packages: read
      actions: read
      security-events: write
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Compute image tag
      run: |
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          TAG=${GITHUB_REF#refs/tags/}
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          TAG="latest"
        else
          TAG='${{ github.ref_name }}'
        fi
        echo "TAG=$TAG" >> $GITHUB_ENV
        echo "Using TAG=$TAG"

    - name: Log in to GHCR
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.TAG }}-linux-amd64
        format: 'sarif'
        output: 'trivy-results.sarif'
        # args: --scanners vuln

    - name: Upload Trivy SARIF as artifact
      uses: actions/upload-artifact@v4
      with:
        name: trivy-sarif
        path: trivy-results.sarif

  # Multi-platform manifest creation
  create-manifest:
    name: Create Multi-Platform Manifest
    runs-on: ubuntu-latest
    needs: [build-matrix, test-matrix]
    if: github.event_name != 'pull_request' && needs.build-matrix.result == 'success'
    permissions:
      contents: read
      packages: write
    steps:
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Compute image tag
      run: |
        if [[ "${{ github.ref }}" == refs/tags/* ]]; then
          TAG=${GITHUB_REF#refs/tags/}
        elif [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          TAG="latest"
        else
          TAG='${{ github.ref_name }}'
        fi
        echo "TAG=$TAG" >> $GITHUB_ENV
        echo "Using TAG=$TAG"

    - name: Create and push multi-platform manifest
      run: |
        echo "::group::Create Multi-Platform Manifest"
        BASE_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
        docker buildx imagetools create -t ${BASE_IMAGE}:${TAG} \
          ${BASE_IMAGE}:${TAG}-linux-amd64 \
          ${BASE_IMAGE}:${TAG}-linux-arm64
        echo "âœ… Multi-platform manifest created: ${BASE_IMAGE}:${TAG}"
        echo "::endgroup::"

  # Release job (only for tags) - åˆ¥ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸ã‚’åŒä¸€ãƒªãƒªãƒ¼ã‚¹ã«æ·»ä»˜
  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [build-matrix, security, create-manifest]
    if: startsWith(github.ref, 'refs/tags/v')
    permissions:
      contents: write
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    # ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ï¼ˆã‚¢ãƒ¼ã‚­åˆ¥ï¼‰
    - name: Download amd64 artifacts
      uses: actions/download-artifact@v4
      with:
        name: hokuyohub-linux-amd64
        path: dist/linux-amd64

    - name: Download arm64 artifacts
      uses: actions/download-artifact@v4
      with:
        name: hokuyohub-linux-arm64
        path: dist/linux-arm64

    # ã‚¢ãƒ¼ã‚­åˆ¥ã« tar.gz ã‚’ä½œæˆ
    - name: Create standalone packages (per-arch)
      run: |
        echo "::group::Create Standalone Packages"
        mkdir -p deployment/amd64 deployment/arm64

        # AMD64
        cp -r dist/linux-amd64/* deployment/amd64/ 2>/dev/null || true
        cat > deployment/amd64/install.sh << 'EOF'
        #!/bin/bash
        set -e
        chmod +x hokuyo_hub || true
        echo "AMD64 package ready. Run: ./hokuyo_hub --config default.yaml"
        EOF
        chmod +x deployment/amd64/install.sh
        tar -czf deployment/hokuyohub-${{ github.ref_name }}-amd64.tar.gz -C deployment/amd64 .

        # ARM64
        cp -r dist/linux-arm64/* deployment/arm64/ 2>/dev/null || true
        cat > deployment/arm64/install.sh << 'EOF'
        #!/bin/bash
        set -e
        chmod +x hokuyo_hub || true
        echo "ARM64 package ready. Run: ./hokuyo_hub --config default.yaml"
        EOF
        chmod +x deployment/arm64/install.sh
        tar -czf deployment/hokuyohub-${{ github.ref_name }}-arm64.tar.gz -C deployment/arm64 .

        ls -lh deployment/
        echo "::endgroup::"

    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          deployment/hokuyohub-${{ github.ref_name }}-amd64.tar.gz
          deployment/hokuyohub-${{ github.ref_name }}-arm64.tar.gz
        generate_release_notes: true
        draft: false
        prerelease: ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') || contains(github.ref, 'rc') }}
        body: |
          ## HokuyoHub ${{ github.ref_name }} - Standalone Packages

          ### ðŸ³ Docker (multi-arch)
          ```bash
          docker pull ghcr.io/${{ github.repository }}:${{ github.ref_name }}
          docker run -d -p 8080:8080 --name hokuyohub ghcr.io/${{ github.repository }}:${{ github.ref_name }}
          ```

          ### ðŸ“¦ Standalone (pick your arch)
          - **AMD64**: `hokuyohub-${{ github.ref_name }}-amd64.tar.gz`
          - **ARM64**: `hokuyohub-${{ github.ref_name }}-arm64.tar.gz`

          ### ðŸŒ Web Interface
          http://localhost:8080

  # Documentation update job
  docs:
    name: Update Documentation
    runs-on: ubuntu-latest
    needs: [create-manifest]
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: write
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Update README with build info
      run: |
        sed -i "s/Build Status: .*/Build Status: [![Build](https:\/\/github.com\/${{ github.repository }}\/actions\/workflows\/docker-matrix-build.yml\/badge.svg)](https:\/\/github.com\/${{ github.repository }}\/actions\/workflows\/docker-matrix-build.yml)/" README.md || true
        mkdir -p docs/build/
        cat > docs/build/PERFORMANCE.md << 'EOF'
        # Build Performance Metrics

        ## Optimized Docker Matrix Build

        - Build Time: Improved via matrix and caching
        - Parallel Execution: linux/amd64 & linux/arm64
        - Caching: BuildKit layer + URG dep cache
        - Runners: 7GB RAM, 2 vCPU

        Last updated: $(date -u '+%Y-%m-%d %H:%M:%S UTC')
        EOF

    - name: Commit documentation updates
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        git add README.md docs/build/ || true
        git diff --staged --quiet || git commit -m "docs: update build performance info [skip ci]"
        git push || true